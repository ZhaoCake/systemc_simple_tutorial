# 实验二：4位带符号位的补码ALU

本实验实现一个4位带符号位的补码算术逻辑单元(ALU)，通过该实验可以理解SystemC中如何实现复杂的组合逻辑和条件判断。

## 实验要求

设计一个能实现以下功能的4位带符号位的补码ALU：

| 功能选择 | 功能     | 操作                          |
|----------|----------|------------------------------|
| 000      | 加法     | A+B                          |
| 001      | 减法     | A-B                          |
| 010      | 取反     | Not A                        |
| 011      | 与       | A and B                      |
| 100      | 或       | A or B                       |
| 101      | 异或     | A xor B                      |
| 110      | 比较大小  | If A<B then out=1; else out=0 |
| 111      | 判断相等  | If A==B then out=1; else out=0 |

ALU进行加减运算时，需要能够判断结果是否为0，是否溢出，是否有进位等。输入的操作数A和B都已经是补码形式的带符号数。比较大小按带符号数的方式进行比较。

执行逻辑操作时不需要考虑overflow和进位。

## 设计原理

### 补码表示法

在4位补码表示法中：
- 最高位是符号位(1表示负数，0表示非负数)
- 数值范围是 -8 到 7
- 对负数 x，其补码表示为 2^4 + x (即16 + x)

例如：
- 5 的补码表示为 0101
- -5 的补码表示为 1011 (即16-5=11，二进制为1011)

### 溢出检测

当对带符号数进行加减运算时，需要考虑溢出问题。溢出发生在以下情况：

1. **加法溢出**：
   - 两个正数相加得到负数
   - 两个负数相加得到正数

2. **减法溢出**：
   - 正数减负数得到负数
   - 负数减正数得到正数

### 进位/借位检测

进位检测需要扩展位宽进行运算，然后观察扩展后的结果是否超出原范围。

## SystemC实现思路

### ALU模块结构

ALU模块包含以下端口：
- 输入：A(4位带符号补码)、B(4位带符号补码)、op(3位操作选择)
- 输出：result(4位带符号结果)、zero(零标志)、overflow(溢出标志)、carry(进位标志)

### 关键实现点

1. **补码操作**：使用SystemC的`sc_int<4>`类型自动处理补码表示
2. **溢出检测**：使用位宽扩展的方法检测溢出
3. **进位检测**：对加减法操作监视最高位是否有进位/借位
4. **逻辑操作**：直接使用C++位运算符实现

### 代码实现

ALU的核心实现如下：

```cpp
void alu_process() {
    sc_int<4> a_val = A.read();
    sc_int<4> b_val = B.read();
    sc_int<4> res = 0;
    bool carry_flag = false;
    bool overflow_flag = false;
    
    switch(op.read()) {
        case 0: // 加法 A+B
            {
                // 扩展位宽进行加法，以检测溢出和进位
                sc_int<5> a_ext = a_val;
                sc_int<5> b_ext = b_val;
                sc_int<5> res_ext = a_ext + b_ext;
                
                // 检测进位和溢出
                carry_flag = ((a_val >= 0 && b_val >= 0 && res_ext >= 8) || 
                             (a_val < 0 && b_val < 0 && res_ext < -8));
                overflow_flag = ((a_val > 0 && b_val > 0 && res_ext < 0) || 
                                (a_val < 0 && b_val < 0 && res_ext >= 0));
                
                res = sc_int<4>(res_ext);
            }
            break;
            
        // ...类似实现其他操作...
    }
    
    // 设置输出
    result.write(res);
    zero.write(res == 0);
    overflow.write(overflow_flag);
    carry.write(carry_flag);
}
```

## 测试平台设计

测试平台需要完成以下任务：
1. 实例化ALU模块
2. 生成各种操作的测试用例
3. 展示和验证结果
4. 记录波形以便分析

### 测试用例包含：
- 加法：正+正、负+负、正数溢出、负数溢出
- 减法：各种组合及溢出情况
- 逻辑操作：取反、与、或、异或
- 比较操作：大小比较、相等判断

### 结果展示

测试平台会详细展示每个操作的输入、输出及标志位状态。例如：

```
A = 3 (0011), B = 4 (0100), Op = 000 [加法 (A+B)]
结果: 7 (0111), 零标志: 否, 溢出标志: 否, 进位标志: 否
-----------------------------------------
```

## 波形分析

生成的波形文件(alu_4bit.vcd)可以用GTKWave等工具查看。波形中可以观察到：
- 每次操作的输入信号(A, B, op)变化
- 结果和标志位如何响应这些变化
- 特殊情况(如溢出)的信号表现

## SystemC学习要点

通过本实验，可以学习到：

1. **数据类型选择**：使用带符号位的sc_int类型处理补码数据
2. **位宽扩展**：如何利用位宽扩展检测溢出和进位
3. **位操作**：SystemC中的位级操作实现
4. **复杂条件判断**：实现多种操作类型和条件检测
5. **信号跟踪**：记录和分析波形以验证电路行为

## 进阶练习

1. 实现一个8位ALU，增加乘法和除法功能
2. 添加移位操作(左移、右移、算术右移)
3. 实现可配置的标志位更新控制
4. 设计一个简单的指令解码器，与ALU配合实现简单的CPU功能
