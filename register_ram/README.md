# 实验三：寄存器堆与RAM实现

本实验实现16×8位的寄存器堆与RAM，重点探究SystemC中如何实现时序逻辑与组合逻辑的区别。

## 实验要点：组合逻辑与时序逻辑

本实验与前两个实验的主要区别是引入了**时序逻辑**。在前面的实验中，我们实现的都是纯组合逻辑电路，而寄存器堆和RAM需要同时实现:

1. **组合逻辑读取** - 输入地址后立即输出数据
2. **时序逻辑写入** - 在时钟上升沿触发数据写入

这种混合逻辑的实现方式在实际硬件设计中非常常见。

### 组合逻辑与时序逻辑的SystemC实现差异

| 特性 | 组合逻辑 | 时序逻辑 |
|------|---------|----------|
| 触发条件 | 输入信号变化 | 时钟边沿 |
| SystemC进程类型 | SC_METHOD | SC_METHOD配合时钟敏感 |
| 敏感信号设置 | `sensitive << input1 << input2;` | `sensitive << clk.pos();` |
| 代码结构 | 直接读输入写输出 | 使用条件检查时钟边沿 |

### 读操作（组合逻辑）实现

寄存器堆的读操作是组合逻辑，实现方式如下：

```cpp
// 读操作过程（组合逻辑，不需要时钟）
void read_process() {
    rd_data.write(registers[rd_addr.read()]);
}

// 注册进程时的敏感列表设置
SC_METHOD(read_process);
sensitive << rd_addr;  // 对读地址敏感，地址一变就立刻读取并输出
```

这段代码表明：
1. 读取过程是**组合逻辑**，使用`SC_METHOD`实现
2. 敏感于`rd_addr`输入信号 - 当读地址变化时，立即执行读取
3. 无需等待时钟，直接读取并输出结果

### 写操作（时序逻辑）实现

寄存器堆的写操作是时序逻辑，实现方式如下：

```cpp
// 写操作过程（时序逻辑，在时钟上升沿写入）
void write_process() {
    if (clk.posedge() && wr_en.read()) {  // 检查时钟上升沿和写使能
        registers[wr_addr.read()] = wr_data.read();
    }
}

// 注册进程时的敏感列表设置
SC_METHOD(write_process);
sensitive << clk.pos();  // 仅对时钟上升沿敏感
```

这段代码表明：
1. 写入过程是**时序逻辑**，使用`SC_METHOD`实现，但敏感于时钟上升沿
2. 在代码中使用`if (clk.posedge() && wr_en.read())`进行条件检查
3. 仅在时钟上升沿且写使能有效时才执行写入操作

### RAM中组合读取和时序写入的统一处理

在RAM模块中，我们将读写操作合并到一个方法中，这是另一种常见模式：

```cpp
// 读写操作过程
void process() {
    // 读操作（组合逻辑）- 不依赖时钟，直接输出
    rd_data.write(memory[addr.read()]);
    
    // 写操作（时序逻辑）- 依赖时钟上升沿
    if (clk.posedge() && wr_en.read()) {
        memory[addr.read()] = wr_data.read();
    }
}

// 注册时需要同时对时钟上升沿和地址变化敏感
SC_METHOD(process);
sensitive << clk.pos() << addr;
```

这段代码表明：
1. 单个方法中同时处理了组合逻辑和时序逻辑
2. 读取部分不依赖时钟条件判断，直接执行
3. 写入部分使用`if`语句检查时钟上升沿
4. 敏感列表同时包含时钟上升沿和地址信号，确保两种行为都能及时触发

### 在SC_THREAD中实现时序逻辑

在测试平台中，我们使用`SC_THREAD`来实现时序控制：

```cpp
// 测试进程
void test_process() {
    // ...setup code...
    
    // 时序控制
    wait(10, SC_NS);  // 等待10ns
    
    // ...test operations...
}

// 注册进程
SC_THREAD(test_process);
sensitive << clk.posedge_event();  // 对时钟上升沿事件敏感
```

`SC_THREAD`与`SC_METHOD`的区别：
1. `SC_THREAD`可以使用`wait`语句暂停执行，模拟真实硬件中的时间延迟
2. `SC_METHOD`每次触发都会完整执行，不能暂停
3. 测试平台通常使用`SC_THREAD`以便灵活控制测试时序

## SystemC中的时钟边沿检测机制：pos()与posedge()的本质区别

```cpp
// 在敏感列表中使用pos()
sensitive << clk.pos();

// 在代码中使用posedge()
if (clk.posedge() && wr_en.read()) {
    // 时序逻辑代码
}
```

这两个函数不仅用途不同，本质上**返回类型也完全不同**：

### 1. `clk.pos()`：返回一个事件对象

- **返回类型**：`sc_event&` - 返回时钟信号上升沿对应的事件对象
- **用途**：专门用于敏感列表中，将进程与特定事件关联
- **工作原理**：告诉SystemC内核"在该事件发生时触发此进程"
- **不能用于条件判断**：它不返回布尔值，不能在if语句中使用
- **示例**：
  ```cpp
  SC_METHOD(write_process);
  sensitive << clk.pos(); // 这里获取的是事件对象，用于设置触发条件
  ```

### 2. `clk.posedge()`：返回一个布尔值

- **返回类型**：`bool` - 返回当前时钟周期是否发生了上升沿转换
- **用途**：用于条件判断，检测当前是否处于上升沿
- **工作原理**：比较当前时钟值与上一周期值，判断是否发生了0→1转换
- **不能用于敏感列表**：它返回布尔值，不是事件对象
- **示例**：
  ```cpp
  void process() {
      if (clk.posedge()) { // 这里获取的是布尔值，用于条件判断
          // 执行时序逻辑
      }
  }
  ```

### 本质区别总结

| 函数 | pos() | posedge() |
|------|-------|-----------|
| 返回类型 | sc_event& (事件引用) | bool (布尔值) |
| 用途 | 设置进程敏感事件 | 进程内部条件判断 |
| 使用位置 | sensitive列表中 | if语句条件表达式中 |
| 含义 | "在上升沿事件时触发" | "当前是否为上升沿" |
| 对应硬件概念 | 时钟信号连接 | 边沿检测电路 |

### RAM模块中的两层边沿检测

在RAM模块中同时使用两种机制的原因：

```cpp
// 设置敏感列表：对时钟上升沿事件和地址变化敏感
SC_METHOD(process);
sensitive << clk.pos() << addr;

// 方法内部仍然需要检测是否当前为时钟上升沿
void process() {
    // 组合逻辑读取（任何时候触发）
    rd_data.write(memory[addr.read()]);
    
    // 时序逻辑写入（仅在确实是时钟上升沿时执行）
    if (clk.posedge() && wr_en.read()) {
        memory[addr.read()] = wr_data.read();
    }
}
```

这看起来像是重复工作，但实际上是两个不同层次的控制：

1. `sensitive << clk.pos()`：在**进程调度级别**设置触发条件
   - 作用于SystemC内核的事件调度机制
   - 决定进程何时被唤醒执行

2. `if (clk.posedge())`：在**进程执行级别**检查当前条件
   - 作用于进程执行流程控制
   - 决定方法体内哪些代码会被执行

当进程因地址变化（而非时钟边沿）被触发时，`clk.posedge()`会返回false，从而跳过写入部分的代码。

这种双重机制是数字电路建模中的常见模式，确保了对时序行为的精确控制和仿真。

## 关键实现细节比较

| 功能 | 实验一：选择器 | 实验三：寄存器堆/RAM |
|------|--------------|-------------------|
| 进程类型 | `SC_METHOD` | 读: `SC_METHOD`<br>写: `SC_METHOD` + 时钟判断 |
| 敏感列表 | 所有输入信号 | 读: 地址信号<br>写: 时钟上升沿 |
| 核心逻辑 | 直接映射关系 | 读: 直接访问<br>写: 条件判断后访问 |
| 是否保存状态 | 否 | 是 |

## 总结：SystemC实现时序逻辑的关键点

1. **时序逻辑的三种实现方式**：
   - `SC_METHOD` + 时钟边沿敏感 + `if (clk.posedge())` 条件判断
   - `SC_THREAD` + 时钟边沿敏感 + `wait()` 语句
   - `SC_CTHREAD` + 时钟边沿触发（专为时钟设计）

2. **组合逻辑和时序逻辑混合实现**：
   - 读操作：直接响应地址变化（组合逻辑）
   - 写操作：仅在时钟边沿响应（时序逻辑）
   - 可以在同一个模块中使用不同进程或在同一进程中区分实现

3. **数据存储与状态保持**：
   - 寄存器堆和RAM需要存储状态，因此在模块内部保存数组
   - 纯组合逻辑（如实验一的选择器）不存储状态

理解这些区别，对于使用SystemC进行数字电路设计至关重要，特别是在设计更复杂的系统如CPU、存储控制器等时。
